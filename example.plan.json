{
  "title": "Example Project Plan",
  "motivation": [
    "This is an example plan file demonstrating the supported features.",
    "",
    "You can write **markdown** in motivation, descriptions, and details,",
    "including $\\LaTeX$ math like $E = mc^2$ and code blocks:",
    "",
    "```python",
    "def hello():",
    "    print('Hello, world!')",
    "```"
  ],
  "children": [
    {
      "name": "Research & Design",
      "short": "Research",
      "icon": "\ud83d\udd2c",
      "description": "Gather requirements, explore existing solutions, and design the architecture.",
      "children": [
        {
          "name": "Survey existing approaches",
          "status": "complete",
          "note": "3 papers reviewed",
          "details": [
            "Reviewed the following:",
            "- Smith et al. (2024) — baseline approach",
            "- Jones & Lee (2023) — improved algorithm with $O(n \\log n)$ complexity",
            "- Park (2024) — state of the art"
          ]
        },
        {
          "name": "Write design document",
          "status": "complete"
        },
        {
          "name": "Get team sign-off",
          "status": "complete",
          "note": "approved 2/15"
        }
      ]
    },
    {
      "name": "Core Implementation",
      "short": "Core",
      "icon": "\u2699\ufe0f",
      "description": [
        "Build the main components of the system.",
        "",
        "Key constraints:",
        "- Must support both batch and streaming modes",
        "- Latency target: < 50ms p99"
      ],
      "children": [
        {
          "name": "Data ingestion pipeline",
          "status": "complete",
          "details": [
            "Implemented a streaming pipeline using:",
            "",
            "```",
            "Source → Parser → Validator → Transformer → Sink",
            "```",
            "",
            "Throughput: ~10k events/sec on a single core."
          ]
        },
        {
          "name": "Processing engine",
          "status": "in_progress",
          "note": "70% done",
          "description": "The core computation engine. Uses a divide-and-conquer strategy.",
          "children": [
            {
              "name": "Implement base algorithm",
              "status": "complete"
            },
            {
              "name": "Add streaming support",
              "status": "in_progress"
            },
            {
              "name": "Optimize hot path",
              "status": "pending"
            }
          ]
        },
        {
          "name": "Output formatter",
          "status": "pending",
          "description": "Formats results as JSON, CSV, or Markdown tables."
        }
      ]
    },
    {
      "name": "Testing & Validation",
      "short": "Testing",
      "description": "Comprehensive test suite covering unit, integration, and performance tests.",
      "children": [
        {
          "name": "Unit tests",
          "status": "in_progress",
          "note": "42/60 passing"
        },
        {
          "name": "Integration tests",
          "status": "pending"
        },
        {
          "name": "Performance benchmarks",
          "status": "pending",
          "details": [
            "Benchmark targets:",
            "",
            "| Metric | Target | Current |",
            "|--------|--------|---------|",
            "| Throughput | 10k/s | TBD |",
            "| Latency p50 | 5ms | TBD |",
            "| Latency p99 | 50ms | TBD |",
            "| Memory | < 512MB | TBD |"
          ]
        }
      ]
    },
    {
      "name": "Documentation & Release",
      "short": "Release",
      "children": [
        {
          "name": "Write user guide",
          "status": "pending"
        },
        {
          "name": "Write API reference",
          "status": "pending"
        },
        {
          "name": "Publish v1.0",
          "status": "deferred",
          "note": "blocked on testing"
        }
      ]
    },
    {
      "name": "Notes & Research",
      "short": "Notes",
      "icon": "\ud83d\udcdd",
      "description": "Reference material and design notes — no status tracking.",
      "children": [
        {
          "name": "Architecture decisions",
          "description": [
            "**ADR-1**: Chose streaming over batch for the ingestion layer.",
            "Rationale: lower latency, better resource utilization under bursty load.",
            "",
            "**ADR-2**: Single-threaded processing engine with async I/O.",
            "We can always shard later; premature parallelism adds complexity."
          ]
        },
        {
          "name": "Useful references",
          "children": [
            {
              "name": "Smith et al. — Baseline approach",
              "description": "Core algorithm we adapted. See Section 3 for the recurrence relation: $T(n) = 2T(n/2) + O(n)$."
            },
            {
              "name": "Jones & Lee — Improved algorithm",
              "description": "Key insight: skip redundant comparisons using a bloom filter. Reduces average case to $O(n \\log \\log n)$."
            }
          ]
        },
        {
          "name": "Algorithm comparison",
          "description": [
            "| Approach | Time | Space | Notes |",
            "|----------|------|-------|-------|",
            "| Brute force | $O(n^2)$ | $O(1)$ | Too slow for $n > 10^4$ |",
            "| Divide & conquer | $O(n \\log n)$ | $O(n)$ | Our current impl |",
            "| Bloom filter | $O(n \\log \\log n)$ | $O(n)$ | Best average case |",
            "| Streaming | $O(n)$ amortized | $O(\\sqrt{n})$ | Requires sorted input |"
          ]
        },
        {
          "name": "Open questions",
          "details": [
            "- How do we handle schema evolution in the ingestion pipeline?",
            "- Should the output formatter support plugins?",
            "- What's the right backpressure strategy for streaming mode?"
          ]
        }
      ]
    }
  ]
}
