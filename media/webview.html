<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src 'unsafe-inline' https://cdnjs.cloudflare.com; script-src 'unsafe-inline' https://cdnjs.cloudflare.com; font-src https://cdnjs.cloudflare.com;">
<title>Plan Tracker</title>
<link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" disabled>
<link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" disabled>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.18/codemirror.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.18/addon/dialog/dialog.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.18/codemirror.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.18/keymap/vim.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.18/addon/dialog/dialog.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.18/addon/search/searchcursor.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.18/mode/markdown/markdown.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/marked/12.0.2/marked.min.js"></script>
<script>
  // VSCode injects vscode-dark/vscode-light on <body>; pick the right hljs theme
  new MutationObserver(() => {
    const dark = document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast');
    document.getElementById('hljs-dark').disabled = !dark;
    document.getElementById('hljs-light').disabled = dark;
  }).observe(document.documentElement, {attributes: true, subtree: true, attributeFilter: ['class']});
  // Also run once after DOM ready
  document.addEventListener('DOMContentLoaded', () => {
    const dark = document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast');
    document.getElementById('hljs-dark').disabled = !dark;
    document.getElementById('hljs-light').disabled = dark;
  });
</script>
<style>
  :root {
    --bg: #fff; --fg: #1a1a2e; --card: #f8f9fa; --border: #dee2e6;
    --green: #28a745; --yellow: #ffc107; --blue: #007bff; --gray: #6c757d; --red: #dc3545;
    --green-bg: #d4edda; --yellow-bg: #fff3cd; --blue-bg: #cce5ff; --gray-bg: #e9ecef;
    --bar-bg: #e9ecef; --hover: #f1f3f5; --detail-bg: #f0f2f5; --code-bg: #e8ecf0;
  }
  body.vscode-dark, body.vscode-high-contrast {
    --bg: #1a1a2e; --fg: #e0e0e0; --card: #16213e; --border: #2a2a4a;
    --green: #4caf50; --yellow: #ffca28; --blue: #42a5f5; --gray: #78909c; --red: #ef5350;
    --green-bg: #1b3d1f; --yellow-bg: #3d3200; --blue-bg: #0d2a4a; --gray-bg: #2a2a3a;
    --bar-bg: #2a2a4a; --hover: #1e2a4a; --detail-bg: #12182e; --code-bg: #0e1525;
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif; background: var(--bg); color: var(--fg); max-width: 960px; margin: 0 auto; padding: 24px; line-height: 1.5; }
  h1 { font-size: 1.6em; margin-bottom: 8px; }
  .subtitle { color: var(--gray); margin-bottom: 24px; font-size: 0.9em; }
  .node-deadline { font-size: 0.72em; font-weight: 500; white-space: nowrap; color: var(--gray); cursor: text; }
  .node-deadline.overdue { color: var(--red); }
  .node-deadline.soon { color: var(--yellow); }
  .node { background: var(--card); border: 1px solid var(--border); border-radius: 8px; margin-bottom: 8px; }
  .node-header { padding: 10px 14px; cursor: pointer; display: flex; align-items: center; gap: 8px; user-select: none; position: sticky; background: var(--card); border-radius: 8px 8px 0 0; box-shadow: 0 1px 0 var(--border); }
  .depth-0 > .node-header { top: 0; z-index: 14; }
  .depth-1 > .node-header { top: 37px; z-index: 13; }
  .depth-2 > .node-header { top: 74px; z-index: 12; }
  .depth-3 > .node-header { top: 111px; z-index: 11; }
  .depth-4 > .node-header { top: 148px; z-index: 10; }
  .node-header:hover { background: var(--hover); }
  .node-header .arrow { font-size: 0.7em; transition: transform 0.2s; color: var(--gray); min-width: 12px; }
  .node-header.open .arrow { transform: rotate(90deg); }
  .node-header .node-id { font-size: 0.72em; color: var(--gray); opacity: 0.5; font-variant-numeric: tabular-nums; white-space: nowrap; min-width: 1.5em; }
  .node-header .node-icon { font-size: 1.1em; cursor: text; }
  .node-header .node-name { font-weight: 500; flex: 1; font-size: 0.9em; }
  .node-header .node-note { font-size: 0.75em; color: var(--gray); font-style: italic; max-width: 220px; text-align: right; }
  .node-header .node-date { font-size: 0.7em; color: var(--gray); opacity: 0.5; white-space: nowrap; }
  .node-header .badge { font-size: 0.72em; padding: 2px 8px; border-radius: 4px; font-weight: 600; cursor: pointer; user-select: none; border: none; transition: opacity 0.15s; white-space: nowrap; }
  .node-header .badge:hover { opacity: 0.8; }
  .badge.complete { background: var(--green-bg); color: var(--green); }
  .badge.in_progress { background: var(--yellow-bg); color: var(--yellow); }
  .badge.pending { background: var(--gray-bg); color: var(--gray); }
  .badge.deferred { background: var(--gray-bg); color: var(--gray); opacity: 0.6; font-style: italic; }
  .badge.note { background: transparent; color: var(--gray); opacity: 0.4; border: 1px dashed var(--border); }
  .node-body { padding: 0 14px 10px; }
  .node-desc { font-size: 0.83em; color: var(--gray); line-height: 1.6; padding-bottom: 8px; border-bottom: 1px solid var(--border); margin-bottom: 8px; }
  .node-details { padding: 8px 12px; margin: 4px 0 8px 0; background: var(--detail-bg); border-radius: 6px; font-size: 0.83em; line-height: 1.6; }
  .node-desc p, .node-details p { margin-bottom: 8px; }
  .node-desc p:last-child, .node-details p:last-child { margin-bottom: 0; }
  .node-desc strong, .node-details strong { font-weight: 600; }
  .node-desc code, .node-details code { background: var(--code-bg); padding: 1px 4px; border-radius: 3px; font-size: 0.92em; }
  .node-desc pre, .node-details pre { background: var(--code-bg); padding: 8px 10px; border-radius: 4px; overflow-x: auto; margin: 6px 0; font-size: 0.88em; line-height: 1.4; }
  .node-desc ul, .node-desc ol, .node-details ul, .node-details ol { margin: 4px 0 8px 20px; }
  .node-desc li, .node-details li { margin-bottom: 2px; }
  .node-desc h1, .node-desc h2, .node-desc h3, .node-details h1, .node-details h2, .node-details h3 { margin: 12px 0 6px; font-weight: 600; }
  .node-desc h1, .node-details h1 { font-size: 1.2em; }
  .node-desc h2, .node-details h2 { font-size: 1.1em; }
  .node-desc h3, .node-details h3 { font-size: 1.0em; }
  .node-desc table, .node-details table { width: 100%; border-collapse: collapse; margin: 8px 0; font-size: 0.95em; }
  .node-desc th, .node-details th { text-align: left; font-weight: 600; padding: 6px 10px; border-bottom: 2px solid var(--border); background: var(--card); }
  .node-desc td, .node-details td { padding: 5px 10px; border-bottom: 1px solid var(--border); }
  .node-desc tr:last-child td, .node-details tr:last-child td { border-bottom: none; }
  .node-desc tr:hover td, .node-details tr:hover td { background: var(--hover); }
  .node-desc blockquote, .node-details blockquote { border-left: 3px solid var(--border); padding-left: 12px; color: var(--gray); margin: 6px 0; }
  .node-desc a, .node-details a { color: var(--blue); text-decoration: none; }
  .node-desc a:hover, .node-details a:hover { text-decoration: underline; }
  .node-children { padding-left: 16px; }
  .depth-0 > .node-header .node-name { font-weight: 600; font-size: 0.95em; }
  .toolbar { display: flex; gap: 8px; margin-top: 24px; padding-top: 16px; border-top: 1px solid var(--border); }
  .btn { padding: 8px 16px; border-radius: 6px; border: 1px solid var(--border); background: var(--card); color: var(--fg); cursor: pointer; font-size: 0.85em; font-weight: 500; transition: background 0.15s; }
  .btn:hover { background: var(--hover); }
  .btn.primary { background: var(--blue); color: #fff; border-color: var(--blue); }
  .btn.primary:hover { opacity: 0.9; }
  .saved-msg { font-size: 0.85em; color: var(--green); align-self: center; opacity: 0; transition: opacity 0.3s; }
  .saved-msg.show { opacity: 1; }
  #loading { text-align: center; padding: 48px; color: var(--gray); }
  /* Editing */
  .node-header .node-actions { display: flex; gap: 2px; opacity: 0; transition: opacity 0.15s; }
  .node-header:hover .node-actions { opacity: 1; }
  .node-actions button { background: none; border: none; cursor: pointer; font-size: 0.8em; padding: 2px 5px; border-radius: 3px; color: var(--gray); line-height: 1; }
  .node-actions button:hover { background: var(--border); }
  .node-actions .del-btn:hover { color: var(--red); }
  .edit-input { width: 100%; padding: 4px 8px; font: inherit; font-size: 0.9em; background: var(--bg); color: var(--fg); border: 2px solid var(--blue); border-radius: 4px; outline: none; }
  /* CodeMirror overrides */
  .CodeMirror { font-family: 'SF Mono', 'Fira Code', monospace; font-size: 0.82em; background: var(--bg); color: var(--fg); border: 2px solid var(--blue); border-radius: 4px; min-height: 120px; height: auto; line-height: 1.5; }
  .CodeMirror-scroll { min-height: 120px; }
  .CodeMirror-cursor { border-left-color: var(--fg); }
  .CodeMirror .cm-fat-cursor .CodeMirror-cursor, .cm-fat-cursor .CodeMirror-cursor { background: var(--fg); opacity: 0.7; }
  .CodeMirror-selected { background: var(--blue-bg) !important; }
  .CodeMirror-focused .CodeMirror-selected { background: var(--blue-bg) !important; }
  .CodeMirror-gutters { background: var(--card); border-right-color: var(--border); }
  .CodeMirror-linenumber { color: var(--gray); }
  .CodeMirror-dialog { background: var(--card); color: var(--fg); border-bottom: 1px solid var(--border); padding: 2px 6px; }
  .CodeMirror-dialog input { color: var(--fg); background: var(--bg); border: 1px solid var(--border); border-radius: 3px; padding: 1px 4px; font-family: monospace; }
  .add-child-btn { display: block; width: 100%; padding: 6px; margin-top: 4px; background: none; border: 2px dashed var(--border); border-radius: 6px; color: var(--gray); cursor: pointer; font-size: 0.8em; transition: all 0.15s; }
  .add-child-btn:hover { border-color: var(--blue); color: var(--blue); background: var(--blue-bg); }
  .dirty-indicator { font-size: 0.85em; color: var(--yellow); align-self: center; }
  /* Drag-and-drop */
  .node-header[draggable="true"] { cursor: grab; }
  .node-header.dragging { opacity: 0.4; }
  .node.drag-over-parent > .node-header { outline: 2px dashed var(--blue); outline-offset: -2px; background: var(--blue-bg); }
  #drop-indicator { position: absolute; left: 0; right: 0; height: 3px; background: var(--blue); border-radius: 2px; pointer-events: none; z-index: 50; display: none; }
  .focusable.focused { outline: 2px solid var(--blue); outline-offset: -2px; border-radius: 6px; }
  /* Settings */
  .settings-toggle { position: fixed; top: 12px; right: 12px; background: var(--card); border: 1px solid var(--border); border-radius: 6px; width: 32px; height: 32px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 1.1em; color: var(--gray); z-index: 100; }
  .settings-toggle:hover { background: var(--hover); color: var(--fg); }
  .settings-panel { position: fixed; top: 50px; right: 12px; background: var(--card); border: 1px solid var(--border); border-radius: 8px; padding: 16px; z-index: 100; min-width: 200px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); display: none; }
  .settings-panel.open { display: block; }
  .settings-panel h3 { font-size: 0.85em; margin-bottom: 12px; font-weight: 600; }
  .settings-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; font-size: 0.82em; }
  .settings-row label { color: var(--gray); }
  .settings-row input[type="range"] { width: 100px; accent-color: var(--blue); }
  .settings-row .val { font-family: monospace; font-size: 0.9em; min-width: 32px; text-align: right; }
  .vim-help { position: fixed; bottom: 16px; right: 16px; background: var(--card); border: 1px solid var(--border); border-radius: 8px; padding: 8px 12px; font-size: 0.75em; color: var(--gray); font-family: monospace; line-height: 1.8; opacity: 0.7; }
  .vim-help kbd { background: var(--border); padding: 1px 5px; border-radius: 3px; font-size: 0.95em; }
  /* Search overlay */
  .search-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.3); z-index: 100; display: flex; justify-content: center; padding-top: 80px; }
  .search-box { width: 500px; max-width: 90vw; max-height: 60vh; background: var(--card); border: 1px solid var(--border); border-radius: 10px; box-shadow: 0 8px 24px rgba(0,0,0,0.25); display: flex; flex-direction: column; overflow: hidden; }
  .search-input { padding: 12px 16px; font: inherit; font-size: 1em; background: transparent; color: var(--fg); border: none; border-bottom: 1px solid var(--border); outline: none; }
  .search-results { overflow-y: auto; flex: 1; }
  .search-item { padding: 8px 16px; cursor: pointer; display: flex; align-items: center; gap: 8px; font-size: 0.88em; }
  .search-item:hover, .search-item.active { background: var(--hover); }
  .search-item .search-path { color: var(--gray); font-size: 0.82em; margin-left: auto; }
  .search-item .search-icon { min-width: 20px; text-align: center; }
  .search-item .search-date { color: var(--gray); font-size: 0.82em; opacity: 0.6; white-space: nowrap; }
  .search-item.create { color: var(--blue); font-style: italic; border-top: 1px solid var(--border); }
  /* Confirm dialog */
  .confirm-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.4); z-index: 200; display: flex; align-items: center; justify-content: center; }
  .confirm-box { background: var(--card); border: 1px solid var(--border); border-radius: 10px; padding: 20px 24px; min-width: 280px; max-width: 400px; box-shadow: 0 8px 24px rgba(0,0,0,0.25); }
  .confirm-box .confirm-msg { font-size: 0.9em; margin-bottom: 16px; line-height: 1.5; }
  .confirm-box .confirm-btns { display: flex; justify-content: flex-end; gap: 8px; }
  .confirm-box .confirm-btn { padding: 6px 16px; border-radius: 6px; border: 1px solid var(--border); background: var(--card); color: var(--fg); cursor: pointer; font-size: 0.85em; font-weight: 500; transition: background 0.15s; }
  .confirm-box .confirm-btn:hover { background: var(--hover); }
  .confirm-box .confirm-btn.danger { background: var(--red); color: #fff; border-color: var(--red); }
  .confirm-box .confirm-btn.danger:hover { opacity: 0.9; }
</style>
</head>
<body>

<div class="settings-toggle" id="settings-toggle" title="Settings">&#9881;</div>
<div class="settings-panel" id="settings-panel">
  <h3>Settings</h3>
  <div class="settings-row">
    <label>Font size</label>
    <input type="range" id="font-size-slider" min="10" max="22" step="1" value="15">
    <span class="val" id="font-size-val">15</span>
  </div>
  <div class="settings-row">
    <label>Vim mode</label>
    <input type="checkbox" id="vim-mode-toggle" checked>
  </div>
  <div class="settings-row">
    <label>Vim hints</label>
    <input type="checkbox" id="vim-hints-toggle">
  </div>
</div>

<div id="loading">Loading plan data...</div>
<div id="drop-indicator"></div>
<div id="app" style="display:none">
  <h1 id="page-title"></h1>
  <p class="subtitle">Double-click text to edit. Click badges to cycle status.</p>
  <div id="tree"></div>
  <div class="toolbar">
    <button class="btn primary" id="save-btn">Save</button>
    <button class="btn" id="revert-btn">Revert</button>
    <span class="saved-msg" id="saved-msg">Saved!</span>
    <span class="dirty-indicator" id="dirty-msg"></span>
    <span style="flex:1"></span>
    <button class="btn" id="expand-all">Expand all</button>
    <button class="btn" id="collapse-all">Collapse all</button>
  </div>
</div>

<script>
// --- VSCode API ---
const vscode = acquireVsCodeApi();

// --- Settings ---
(function initSettings() {
  const state = vscode.getState() || {};
  const fontSize = state.fontSize || 15;
  document.body.style.fontSize = fontSize + 'px';
  const slider = document.getElementById('font-size-slider');
  const valEl = document.getElementById('font-size-val');
  slider.value = fontSize;
  valEl.textContent = fontSize;

  slider.addEventListener('input', () => {
    const sz = parseInt(slider.value, 10);
    valEl.textContent = sz;
    document.body.style.fontSize = sz + 'px';
    vscode.setState({ ...vscode.getState(), fontSize: sz });
  });

  // Vim mode toggle
  const vimToggle = document.getElementById('vim-mode-toggle');
  window.vimEnabled = state.vimMode !== false; // default on
  vimToggle.checked = window.vimEnabled;
  vimToggle.addEventListener('change', () => {
    window.vimEnabled = vimToggle.checked;
    vscode.setState({ ...vscode.getState(), vimMode: window.vimEnabled });
    const help = document.getElementById('vim-help');
    if (help) help.style.display = (window.vimEnabled && hintsToggle.checked) ? '' : 'none';
  });

  // Vim hints toggle
  const hintsToggle = document.getElementById('vim-hints-toggle');
  const showHints = state.vimHints === true; // default off
  hintsToggle.checked = showHints;
  // Apply after vim-help element is created (deferred)
  setTimeout(() => {
    const help = document.getElementById('vim-help');
    if (help) help.style.display = (showHints && window.vimEnabled) ? '' : 'none';
  }, 0);
  hintsToggle.addEventListener('change', () => {
    const on = hintsToggle.checked;
    const help = document.getElementById('vim-help');
    if (help) help.style.display = (on && window.vimEnabled) ? '' : 'none';
    vscode.setState({ ...vscode.getState(), vimHints: on });
  });

  document.getElementById('settings-toggle').addEventListener('click', () => {
    document.getElementById('settings-panel').classList.toggle('open');
  });

  // Close settings when clicking elsewhere
  document.addEventListener('click', e => {
    const panel = document.getElementById('settings-panel');
    const toggle = document.getElementById('settings-toggle');
    if (panel.classList.contains('open') && !panel.contains(e.target) && !toggle.contains(e.target)) {
      panel.classList.remove('open');
    }
  });
})();

const STATUS_ORDER = ['pending', 'in_progress', 'complete'];
const STATUS_LABELS = {complete: 'Complete', in_progress: 'In Progress', pending: 'Pending', deferred: 'Deferred'};
const STATUS_COLORS = {complete: 'var(--green)', in_progress: 'var(--yellow)', pending: 'var(--gray)', deferred: 'var(--gray)'};

let data = null;
let dirty = false;
let editing = false;
let vimFocusKey = null;
let dragSourcePath = null;
const openNodes = new Set();
const openDetailsSet = new Set();

function txt(v) { return Array.isArray(v) ? v.join('\n') : (v || ''); }

function unwrap(v) {
  if (!Array.isArray(v)) return v || '';
  const out = []; let buf = [];
  function flush() {
    if (!buf.length) return;
    if (buf.every(l => !/^[-*] |^\d+\. |^\||^```|^#/.test(l))) out.push(buf.join(' '));
    else buf.forEach(l => out.push(l));
    buf = [];
  }
  for (const l of v) { if (l === '') { flush(); out.push(''); } else buf.push(l); }
  flush();
  return out.join('\n');
}

function markDirty() {
  dirty = true;
  document.getElementById('dirty-msg').textContent = 'Unsaved changes';
}

function touchNode(node, isNew) {
  const now = new Date().toISOString();
  if (isNew) node.created = now;
  node.modified = now;
}

function relTime(iso) {
  if (!iso) return '';
  const diff = Date.now() - new Date(iso).getTime();
  const s = Math.floor(diff / 1000);
  if (s < 60) return 'just now';
  const m = Math.floor(s / 60);
  if (m < 60) return `${m}m ago`;
  const h = Math.floor(m / 60);
  if (h < 24) return `${h}h ago`;
  const d = Math.floor(h / 24);
  if (d < 30) return `${d}d ago`;
  const mo = Math.floor(d / 30);
  if (mo < 12) return `${mo}mo ago`;
  return `${Math.floor(mo / 12)}y ago`;
}

function fmtDeadline(iso) {
  if (!iso) return '';
  const d = new Date(iso + 'T00:00:00');
  const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  return months[d.getMonth()] + ' ' + d.getDate();
}
function deadlineClass(iso) {
  if (!iso) return '';
  const now = new Date(); now.setHours(0,0,0,0);
  const d = new Date(iso + 'T00:00:00');
  const diff = (d - now) / 86400000;
  if (diff < 0) return 'overdue';
  if (diff <= 3) return 'soon';
  return '';
}

function nodeAt(path) {
  let node = data;
  for (const i of path) node = node.children[i];
  return node;
}

// --- Data from extension via postMessage ---
window.addEventListener('message', e => {
  const msg = e.data;
  if (msg.type === 'load') {
    const firstLoad = !data;
    data = msg.data;
    document.getElementById('loading').style.display = 'none';
    document.getElementById('app').style.display = '';
    if (firstLoad) data.children.forEach((c,i) => autoOpen(c, [i]));
    if (!dirty && !editing) render();
  } else if (msg.type === 'saved') {
    dirty = false;
    document.getElementById('dirty-msg').textContent = '';
    const el = document.getElementById('saved-msg');
    el.classList.add('show');
    setTimeout(() => el.classList.remove('show'), 2000);
  }
});

// --- Status derivation ---
function isLeaf(node) { return !node.children || node.children.length === 0; }

function deriveStatus(node) {
  if (isLeaf(node)) return node.status || null;
  const kids = node.children.filter(c => { const s = deriveStatus(c); return s && s !== 'deferred'; });
  if (kids.length === 0) return null;
  if (kids.every(c => deriveStatus(c) === 'complete')) return 'complete';
  if (kids.some(c => deriveStatus(c) === 'in_progress')) return 'in_progress';
  if (kids.some(c => deriveStatus(c) === 'complete')) return 'in_progress';
  return 'pending';
}

function countProgress(node) {
  if (isLeaf(node)) {
    const s = node.status;
    if (!s || s === 'deferred') return {done:0, total:0};
    return {done: s === 'complete' ? 1 : 0, total: 1};
  }
  let done = 0, total = 0;
  for (const c of node.children) { const p = countProgress(c); done += p.done; total += p.total; }
  return {done, total};
}

function hasAnyStatus(node) {
  if (isLeaf(node)) return !!node.status;
  if (!node.children) return false;
  return node.children.some(c => hasAnyStatus(c));
}

function pathKey(path) { return path.join('-'); }

// --- Search ---
function flattenNodes(node, path, ancestors) {
  const results = [];
  if (path.length > 0) {
    results.push({ node, path: [...path], ancestors: [...ancestors], name: node.name });
  }
  if (node.children) {
    const label = node.name || node.title || '';
    node.children.forEach((c, i) => {
      results.push(...flattenNodes(c, [...path, i], path.length > 0 ? [...ancestors, label] : ancestors));
    });
  }
  return results;
}

function searchNodes(query) {
  if (!data) return [];
  const all = flattenNodes(data, [], []);
  const isTodo = item => hasAnyStatus(item.node);
  const modTime = item => item.node.modified ? new Date(item.node.modified).getTime() : 0;
  if (!query.trim()) {
    // No query: todos first, then notes, each sorted by most recently modified
    return all
      .sort((a, b) => {
        const aTodo = isTodo(a), bTodo = isTodo(b);
        if (aTodo !== bTodo) return aTodo ? -1 : 1;
        return modTime(b) - modTime(a);
      })
      .slice(0, 30);
  }
  const q = query.toLowerCase();
  return all
    .map(item => {
      const name = item.name.toLowerCase();
      const desc = (typeof item.node.description === 'string' ? item.node.description : Array.isArray(item.node.description) ? item.node.description.join(' ') : '').toLowerCase();
      let score = 0;
      if (name.startsWith(q)) score = 3;
      else if (name.includes(q)) score = 2;
      else if (desc.includes(q)) score = 1;
      // Boost todos over notes at same match level
      if (score > 0 && isTodo(item)) score += 0.5;
      return { ...item, score };
    })
    .filter(item => item.score > 0)
    .sort((a, b) => b.score - a.score || modTime(b) - modTime(a));
}

let searchOpen = false;

function navigateToNode(path) {
  for (let i = 1; i < path.length; i++) {
    openNodes.add(pathKey(path.slice(0, i)));
  }
  const node = nodeAt(path);
  if (isLeaf(node) && (node.description || node.details)) {
    openDetailsSet.add(pathKey(path));
  }
  renderTree(); highlight();
  const pk = pathKey(path);
  vimFocusKey = 'h:' + pk;
  const el = document.querySelector(`[data-fkey="h:${pk}"]`);
  if (el) {
    el.classList.add('focused');
    el.scrollIntoView({ block: 'center', behavior: 'smooth' });
  }
}

function openSearch() {
  if (editing || searchOpen) return;
  searchOpen = true;
  const overlay = document.createElement('div');
  overlay.className = 'search-overlay';
  overlay.innerHTML = `<div class="search-box">
    <input class="search-input" placeholder="Search nodes..." autofocus>
    <div class="search-results"></div>
  </div>`;
  document.body.appendChild(overlay);

  const input = overlay.querySelector('.search-input');
  const resultsEl = overlay.querySelector('.search-results');
  let activeIdx = 0;
  let results = [];

  function updateResults() {
    results = searchNodes(input.value);
    const q = input.value.trim();
    resultsEl.innerHTML = results.map((r, i) => {
      const icon = r.node.icon || '';
      const breadcrumb = r.ancestors.length ? r.ancestors.join(' \u203a ') : '';
      const dateStr = r.node.modified ? relTime(r.node.modified) : '';
      return `<div class="search-item ${i === activeIdx ? 'active' : ''}" data-idx="${i}">
        <span class="search-icon">${icon}</span>
        <span>${escHtml(r.name)}</span>
        ${breadcrumb ? `<span class="search-path">${escHtml(breadcrumb)}</span>` : ''}
        ${dateStr ? `<span class="search-date">${dateStr}</span>` : ''}
      </div>`;
    }).join('')
    + (q ? `<div class="search-item create ${activeIdx === results.length ? 'active' : ''}" data-idx="${results.length}">+ Create &ldquo;${escHtml(q)}&rdquo;</div>` : '');

    resultsEl.querySelectorAll('.search-item').forEach(el => {
      el.addEventListener('click', () => selectItem(parseInt(el.dataset.idx)));
    });
    const activeEl = resultsEl.querySelector('.search-item.active');
    if (activeEl) activeEl.scrollIntoView({ block: 'nearest' });
  }

  function selectItem(idx) {
    if (idx === results.length) {
      const newNode = { name: input.value.trim() };
      touchNode(newNode, true);
      data.children.push(newNode);
      markDirty();
      const newPath = [data.children.length - 1];
      closeSearch();
      render();
      navigateToNode(newPath);
    } else if (results[idx]) {
      const path = results[idx].path;
      closeSearch();
      navigateToNode(path);
    }
  }

  function closeSearch() {
    searchOpen = false;
    overlay.remove();
  }

  input.addEventListener('input', () => { activeIdx = 0; updateResults(); });
  input.addEventListener('keydown', e => {
    if (e.key === 'Escape') { e.preventDefault(); closeSearch(); return; }
    if (e.key === 'ArrowDown' || (e.key === 'j' && e.ctrlKey)) {
      e.preventDefault();
      const max = results.length + (input.value.trim() ? 1 : 0);
      activeIdx = Math.min(activeIdx + 1, max - 1);
      updateResults(); return;
    }
    if (e.key === 'ArrowUp' || (e.key === 'k' && e.ctrlKey)) {
      e.preventDefault();
      activeIdx = Math.max(activeIdx - 1, 0);
      updateResults(); return;
    }
    if (e.key === 'Enter') { e.preventDefault(); selectItem(activeIdx); return; }
  });

  overlay.addEventListener('click', e => { if (e.target === overlay) closeSearch(); });
  updateResults();
  input.focus();
}

document.addEventListener('keydown', e => {
  if ((e.metaKey || e.ctrlKey) && e.key === 'f' && !editing && !searchOpen) {
    e.preventDefault();
    openSearch();
  }
  if ((e.metaKey || e.ctrlKey) && e.key === 's') {
    e.preventDefault();
    vscode.postMessage({ type: 'save', data });
  }
});

function autoOpen(node, path) {
  if (deriveStatus(node) === 'in_progress' && !isLeaf(node)) openNodes.add(pathKey(path));
  if (node.children) node.children.forEach((c,i) => autoOpen(c, [...path, i]));
}

function cycleLeafStatus(node) {
  if (!isLeaf(node) || node.status === 'deferred') return;
  if (!node.status) {
    node.status = 'pending';
  } else {
    const idx = STATUS_ORDER.indexOf(node.status);
    if (idx === STATUS_ORDER.length - 1) {
      delete node.status;
    } else {
      node.status = STATUS_ORDER[idx + 1];
    }
  }
  touchNode(node);
  markDirty();
  render();
}

// --- CodeMirror vim setup (global, runs once) ---
(function setupVim() {
  CodeMirror.Vim.map('jk', '<Esc>', 'insert');
  CodeMirror.Vim.defineEx('write', 'w', function(cm) { if (cm._save) cm._save(); });
  CodeMirror.Vim.defineEx('quit', 'q', function(cm) { if (cm._save) cm._save(); });
  CodeMirror.Vim.defineEx('wq', 'wq', function(cm) { if (cm._save) cm._save(); });
})();

// --- Inline editing ---
function startEdit(el, path, field, multiline, vimNormal) {
  if (editing) return;
  editing = true;
  const node = nodeAt(path);
  const raw = multiline ? unwrap(node[field] || '') : txt(node[field] || '');

  if (multiline) {
    const wrapper = document.createElement('div');
    el.replaceWith(wrapper);
    const cm = CodeMirror(wrapper, {
      value: raw,
      mode: 'markdown',
      keyMap: 'vim',
      lineWrapping: true,
      viewportMargin: Infinity,
      inputStyle: 'textarea',
    });
    const save = () => {
      if (!editing) return;
      editing = false;
      const val = cm.getValue();
      if (val !== raw) { node[field] = val ? val.split('\n') : undefined; touchNode(node); markDirty(); }
      renderTree(); highlight();
    };
    cm._save = save;
    // Normal mode: Escape/Enter/jk exit the editor
    let jkPending = false, jkTimer = null;
    cm.on('keydown', (instance, event) => {
      const vim = cm.state.vim;
      if (!vim || vim.insertMode || vim.visualMode) { jkPending = false; clearTimeout(jkTimer); return; }
      if (event.key === 'Escape' || event.key === 'Enter') {
        event.preventDefault(); event.stopPropagation();
        save(); return;
      }
      if (event.key === 'j') {
        jkPending = true; event.preventDefault();
        jkTimer = setTimeout(() => { if (jkPending) { jkPending = false; CodeMirror.Vim.handleKey(cm, 'j'); } }, 200);
        return;
      }
      if (event.key === 'k' && jkPending) {
        jkPending = false; clearTimeout(jkTimer);
        event.preventDefault(); event.stopPropagation();
        save(); return;
      }
      if (jkPending) { jkPending = false; clearTimeout(jkTimer); CodeMirror.Vim.handleKey(cm, 'j'); }
    });
    cm.on('blur', () => { setTimeout(() => { if (!cm.hasFocus()) save(); }, 150); });
    // Start in insert mode unless vimNormal
    if (!vimNormal) CodeMirror.Vim.handleKey(cm, 'i');
    cm.focus();
    wrapper.scrollIntoView({block: 'nearest', behavior: 'smooth'});
  } else {
    const input = document.createElement('input');
    input.className = 'edit-input';
    input.value = raw;
    el.replaceWith(input);
    input.focus();
    input.select();
    input.scrollIntoView({block: 'nearest', behavior: 'smooth'});
    const save = () => {
      if (!editing) return;
      editing = false;
      const val = input.value.trim();
      if (val !== raw) { node[field] = val || undefined; touchNode(node); markDirty(); }
      render();
    };
    input.addEventListener('blur', save);
    let jkP = false, jkT = null;
    function insertJ() {
      const s = input.selectionStart, e = input.selectionEnd;
      input.value = input.value.slice(0, s) + 'j' + input.value.slice(e);
      input.selectionStart = input.selectionEnd = s + 1;
    }
    input.addEventListener('keydown', e => {
      if (e.key === 'Enter') { save(); return; }
      if (e.key === 'Escape') { editing = false; render(); return; }
      // jk macro â†’ Escape
      if (e.key === 'j') {
        e.preventDefault();
        jkP = true;
        jkT = setTimeout(() => { if (jkP) { jkP = false; insertJ(); } }, 200);
        return;
      }
      if (e.key === 'k' && jkP) {
        e.preventDefault();
        jkP = false; clearTimeout(jkT);
        editing = false; render();
        return;
      }
      if (jkP) { jkP = false; clearTimeout(jkT); insertJ(); }
    });
  }
}

function addChild(path) {
  const parent = path.length === 0 ? data : nodeAt(path);
  if (!parent.children) parent.children = [];
  const newNode = {name: 'New node'};
  touchNode(newNode, true);
  parent.children.push(newNode);
  const pk = pathKey(path);
  openNodes.add(pk);
  markDirty();
  render();
}

function editDescription(path) {
  const node = nodeAt(path);
  const pk = pathKey(path);
  if (!node.description) node.description = [];
  if (isLeaf(node)) openDetailsSet.add(pk); else openNodes.add(pk);
  renderTree(); highlight();
  const descEl = document.querySelector(`[data-fkey="c:${pk}:description"]`);
  if (descEl) startEdit(descEl, path, 'description', true, false);
}

function showConfirm(msg) {
  return new Promise(resolve => {
    const overlay = document.createElement('div');
    overlay.className = 'confirm-overlay';
    overlay.innerHTML = `<div class="confirm-box">
      <div class="confirm-msg">${msg}</div>
      <div class="confirm-btns">
        <button class="confirm-btn cancel">Cancel</button>
        <button class="confirm-btn danger">Delete</button>
      </div>
    </div>`;
    const cleanup = (val) => { overlay.remove(); document.removeEventListener('keydown', onKey); resolve(val); };
    overlay.querySelector('.cancel').addEventListener('click', () => cleanup(false));
    overlay.querySelector('.danger').addEventListener('click', () => cleanup(true));
    overlay.addEventListener('click', e => { if (e.target === overlay) cleanup(false); });
    const onKey = e => { if (e.key === 'Escape') cleanup(false); else if (e.key === 'Enter') cleanup(true); };
    document.addEventListener('keydown', onKey);
    document.body.appendChild(overlay);
    overlay.querySelector('.danger').focus();
  });
}

async function deleteNode(path) {
  const node = nodeAt(path);
  const name = node.name || 'this node';
  if (!await showConfirm(`Delete <strong>"${name}"</strong>?`)) return;
  const parentPath = path.slice(0, -1);
  const idx = path[path.length - 1];
  const parent = parentPath.length === 0 ? data : nodeAt(parentPath);
  parent.children.splice(idx, 1);
  if (parent.children.length === 0 && parent !== data) {
    delete parent.children;
    if (!parent.status) parent.status = 'pending';
  }
  markDirty();
  render();
}

// --- Markdown to HTML (via marked + KaTeX) ---
function renderMd(text) {
  if (!text) return '';
  // Protect code fences and inline code from LaTeX extraction
  const codes = [];
  text = text.replace(/```[\s\S]*?```|`[^`\n]+`/g, m => { codes.push(m); return `\x00C${codes.length-1}\x00`; });
  // Protect LaTeX delimiters from markdown processing
  const lx = [];
  text = text.replace(/\$\$[\s\S]+?\$\$|\\\[[\s\S]+?\\\]|\$[^\$\n]+?\$|\\\([^\)]+?\\\)/g, m => { lx.push(m); return `\x00L${lx.length-1}\x00`; });
  // Restore code fences before marked processes them
  text = text.replace(/\x00C(\d+)\x00/g, (_, i) => codes[parseInt(i)]);
  let html = marked.parse(text, { gfm: true, breaks: false });
  // Restore LaTeX with HTML escaping
  html = html.replace(/\x00L(\d+)\x00/g, (_, i) => lx[parseInt(i)].replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;'));
  return html;
}
function escHtml(t) { return t.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

function highlight() {
  if (typeof hljs !== 'undefined') {
    document.querySelectorAll('pre code').forEach(el => { hljs.highlightElement(el); });
  }
  if (typeof renderMathInElement !== 'undefined') {
    document.querySelectorAll('.node-desc, .node-details').forEach(el => {
      renderMathInElement(el, {
        delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '$', right: '$', display: false},
          {left: '\\(', right: '\\)', display: false},
          {left: '\\[', right: '\\]', display: true},
        ],
        throwOnError: false,
      });
    });
  }
}

// --- Render ---
function editRootField(el, field, placeholder) {
  if (editing) return;
  editing = true;
  const raw = data[field] || '';
  const input = document.createElement('input');
  input.className = 'edit-input';
  input.value = raw;
  input.placeholder = placeholder || '';
  input.style.fontSize = getComputedStyle(el).fontSize;
  input.style.fontWeight = getComputedStyle(el).fontWeight;
  el.textContent = '';
  el.appendChild(input);
  input.focus();
  input.select();
  let saved = false;
  const save = () => {
    if (saved) return;
    saved = true;
    editing = false;
    const val = input.value.trim();
    if (val !== raw) { data[field] = val || undefined; markDirty(); }
    render();
  };
  input.addEventListener('blur', save);
  input.addEventListener('keydown', e => {
    if (e.key === 'Enter') { e.preventDefault(); save(); }
    if (e.key === 'Escape') { e.preventDefault(); saved = true; editing = false; render(); }
  });
}

function render() {
  if (!data) return;
  const titleEl = document.getElementById('page-title');
  titleEl.textContent = data.title || 'Untitled';
  titleEl.ondblclick = () => editRootField(titleEl, 'title', 'Title');

  const subEl = document.querySelector('.subtitle');
  subEl.textContent = data.subtitle || 'Double-click to add a description...';
  if (data.subtitle) subEl.style.fontStyle = 'normal'; else subEl.style.fontStyle = 'italic';
  subEl.ondblclick = () => editRootField(subEl, 'subtitle', 'Description');

  renderTree();
  highlight();
}

function toggleNode(pk) {
  if (openNodes.has(pk)) openNodes.delete(pk); else openNodes.add(pk);
  renderTree(); highlight();
}
function toggleDetails(pk) {
  if (openDetailsSet.has(pk)) openDetailsSet.delete(pk); else openDetailsSet.add(pk);
  renderTree(); highlight();
}

function renderTree() {
  document.getElementById('tree').innerHTML = data.children.map((c,i) => renderNode(c, [i], 0)).join('');
  document.getElementById('tree').querySelectorAll('[data-edit]').forEach(el => {
    el.addEventListener('dblclick', e => {
      e.stopPropagation();
      const path = JSON.parse(el.dataset.path);
      const field = el.dataset.field;
      const multi = el.dataset.edit === 'multi';
      startEdit(el, path, field, multi);
    });
  });
  if (vimFocusKey) {
    const el = document.querySelector(`[data-fkey="${vimFocusKey}"]`);
    if (el) el.classList.add('focused');
  }
}

function renderNode(node, path, depth) {
  const pk = pathKey(path);
  const leaf = isLeaf(node);
  const status = deriveStatus(node);
  const isOpen = openNodes.has(pk);
  const detailOpen = openDetailsSet.has(pk);
  const {done, total} = countProgress(node);
  const statusLabel = !leaf && status === 'in_progress' ? `${done}/${total}` : STATUS_LABELS[status];
  const hasDetails = !!node.details;
  const hasDesc = !!node.description;
  const hasChildren = !leaf;
  const canExpand = hasChildren || hasDetails || hasDesc;
  const ps = JSON.stringify(path);

  let badgeHtml = '';
  if (status) {
    if (leaf) {
      badgeHtml = `<span class="badge ${status}" onclick="event.stopPropagation(); cycleAt([${path}])">${statusLabel}</span>`;
    } else {
      badgeHtml = `<span class="badge ${status}">${statusLabel}</span>`;
    }
  } else if (leaf) {
    badgeHtml = `<span class="badge note" onclick="event.stopPropagation(); cycleAt([${path}])">note</span>`;
  }

  const dlClass = deadlineClass(node.deadline);
  const deadlineHtml = node.deadline
    ? `<span class="node-deadline ${dlClass}" data-edit="single" data-path='${ps}' data-field="deadline" title="Due: ${new Date(node.deadline + 'T00:00:00').toLocaleDateString()}">due ${fmtDeadline(node.deadline)}</span>`
    : '';

  const actions = `<span class="node-actions">
    <button onclick="event.stopPropagation(); addChild([${path}])" title="Add child">+</button>
    <button onclick="event.stopPropagation(); editDescription([${path}])" title="Edit description">&#9998;</button>
    <button class="del-btn" onclick="event.stopPropagation(); deleteNode([${path}])" title="Delete">&times;</button>
  </span>`;

  let bodyHtml = '';
  if (isOpen || (leaf && detailOpen)) {
    let inner = '';
    if (hasDesc) inner += `<div class="node-desc focusable" data-edit="multi" data-path='${ps}' data-field="description" data-fkey="c:${pk}:description">${renderMd(txt(node.description))}</div>`;
    if (detailOpen && hasDetails) inner += `<div class="node-details focusable" data-edit="multi" data-path='${ps}' data-field="details" data-fkey="c:${pk}:details">${renderMd(txt(node.details))}</div>`;
    if (hasChildren) {
      inner += `<div class="node-children">${node.children.map((c,i) => renderNode(c, [...path, i], depth+1)).join('')}`;
      inner += `<button class="add-child-btn" onclick="addChild([${path}])">+ Add step</button></div>`;
    }
    if (inner) bodyHtml = `<div class="node-body">${inner}</div>`;
  }

  const clickAction = hasChildren
    ? `toggleNode('${pk}')`
    : (hasDetails || hasDesc) ? `toggleDetails('${pk}')` : '';

  return `<div class="node depth-${depth}" data-path='${ps}'>
    <div class="node-header focusable ${isOpen || detailOpen ? 'open' : ''}" data-pk="${pk}" data-fkey="h:${pk}" onclick="${clickAction}" draggable="true" data-path='${ps}'>
      ${canExpand ? `<span class="arrow">&#9654;</span>` : `<span class="arrow" style="visibility:hidden">&#9654;</span>`}
      <span class="node-id">${path.map(i => i + 1).join('.')}</span>
      ${node.icon ? `<span class="node-icon" data-edit="single" data-path='${ps}' data-field="icon">${node.icon}</span>` : ''}
      <span class="node-name" data-edit="single" data-path='${ps}' data-field="name">${escHtml(node.name)}</span>
      <span class="node-note" data-edit="single" data-path='${ps}' data-field="note">${node.note ? escHtml(node.note) : ''}</span>
      ${deadlineHtml}
      ${node.modified ? `<span class="node-date" title="${node.created ? 'Created: ' + new Date(node.created).toLocaleString() + '\n' : ''}Modified: ${new Date(node.modified).toLocaleString()}">${relTime(node.modified)}</span>` : ''}
      ${actions}
      ${badgeHtml}
    </div>
    ${bodyHtml}
  </div>`;
}

function cycleAt(path) { cycleLeafStatus(nodeAt(path)); }

// --- Save (writes to disk via extension) ---
document.getElementById('save-btn').addEventListener('click', () => {
  vscode.postMessage({ type: 'save', data });
});

document.getElementById('revert-btn').addEventListener('click', async () => {
  if (!dirty) return;
  if (!await showConfirm('Discard unsaved changes and revert to the last saved version?')) return;
  dirty = false;
  editing = false;
  document.getElementById('dirty-msg').textContent = '';
  vscode.postMessage({ type: 'revert' });
});

document.getElementById('expand-all').addEventListener('click', () => {
  function expandAll(node, path) {
    const pk = pathKey(path);
    if (!isLeaf(node)) { openNodes.add(pk); node.children.forEach((c,i) => expandAll(c, [...path, i])); }
    if (node.details) openDetailsSet.add(pk);
  }
  data.children.forEach((c,i) => expandAll(c, [i]));
  render();
});

document.getElementById('collapse-all').addEventListener('click', () => {
  openNodes.clear(); openDetailsSet.clear(); render();
});

// --- Drag-and-drop ---
function isDescendantOrSelf(targetPath, sourcePath) {
  if (targetPath.length < sourcePath.length) return false;
  return sourcePath.every((v, i) => targetPath[i] === v);
}

function showDropLine(yPosition) {
  const el = document.getElementById('drop-indicator');
  el.style.display = 'block';
  el.style.top = (yPosition + window.scrollY) + 'px';
}

function clearDropVisuals() {
  document.getElementById('drop-indicator').style.display = 'none';
  document.querySelectorAll('.drag-over-parent').forEach(el => el.classList.remove('drag-over-parent'));
  document.querySelectorAll('[data-drop-position]').forEach(el => delete el.dataset.dropPosition);
}

function stampOpenState() {
  function walk(node, path) {
    const pk = pathKey(path);
    if (openNodes.has(pk)) node._open = true;
    if (openDetailsSet.has(pk)) node._detailOpen = true;
    if (node.children) node.children.forEach((c, i) => walk(c, [...path, i]));
  }
  data.children.forEach((c, i) => walk(c, [i]));
}

function restoreOpenState() {
  openNodes.clear();
  openDetailsSet.clear();
  function walk(node, path) {
    const pk = pathKey(path);
    if (node._open) { openNodes.add(pk); delete node._open; }
    if (node._detailOpen) { openDetailsSet.add(pk); delete node._detailOpen; }
    if (node.children) node.children.forEach((c, i) => walk(c, [...path, i]));
  }
  data.children.forEach((c, i) => walk(c, [i]));
}

function adjustPathAfterRemoval(targetPath, srcPath, srcIdx) {
  const srcParentPath = srcPath.slice(0, -1);
  if (srcParentPath.length >= targetPath.length) return targetPath;
  const sameParent = srcParentPath.every((v, i) => targetPath[i] === v);
  if (!sameParent) return targetPath;
  const d = srcParentPath.length;
  if (targetPath[d] > srcIdx) {
    const adjusted = [...targetPath];
    adjusted[d]--;
    return adjusted;
  }
  return targetPath;
}

function performMove(srcPath, tgtPath, position) {
  stampOpenState();

  const srcParentPath = srcPath.slice(0, -1);
  const srcIdx = srcPath[srcPath.length - 1];
  const srcParent = srcParentPath.length === 0 ? data : nodeAt(srcParentPath);
  const [movedNode] = srcParent.children.splice(srcIdx, 1);

  if (srcParent.children.length === 0 && srcParent !== data) {
    delete srcParent.children;
    if (!srcParent.status) srcParent.status = undefined;
  }

  if (position === 'into') {
    const adjPath = adjustPathAfterRemoval(tgtPath, srcPath, srcIdx);
    const tgtNode = nodeAt(adjPath);
    if (!tgtNode.children) tgtNode.children = [];
    tgtNode.children.push(movedNode);
    tgtNode._open = true;
  } else {
    const adjPath = adjustPathAfterRemoval(tgtPath, srcPath, srcIdx);
    const tgtParentPath = adjPath.slice(0, -1);
    let tgtIdx = adjPath[adjPath.length - 1];
    if (position === 'after') tgtIdx++;
    const tgtParent = tgtParentPath.length === 0 ? data : nodeAt(tgtParentPath);
    tgtParent.children.splice(tgtIdx, 0, movedNode);
  }

  restoreOpenState();
  markDirty();
  render();
}

(function setupDragHandlers() {
  const tree = document.getElementById('tree');

  tree.addEventListener('dragstart', e => {
    const header = e.target.closest('.node-header');
    if (!header || editing) { e.preventDefault(); return; }
    if (e.target.closest('.badge') || e.target.closest('.node-actions') || e.target.closest('.node-icon')) {
      e.preventDefault(); return;
    }
    dragSourcePath = JSON.parse(header.dataset.path);
    header.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', '');
  });

  tree.addEventListener('dragend', () => {
    dragSourcePath = null;
    clearDropVisuals();
    document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
  });

  tree.addEventListener('dragover', e => {
    if (!dragSourcePath) return;
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';

    const header = e.target.closest('.node-header');
    if (!header) { clearDropVisuals(); return; }

    const targetPath = JSON.parse(header.dataset.path);
    if (isDescendantOrSelf(targetPath, dragSourcePath)) { clearDropVisuals(); return; }

    const rect = header.getBoundingClientRect();
    const ratio = (e.clientY - rect.top) / rect.height;
    const nodeEl = header.closest('.node');

    clearDropVisuals();

    if (ratio < 0.25) {
      showDropLine(rect.top);
      nodeEl.dataset.dropPosition = 'before';
    } else if (ratio > 0.75) {
      showDropLine(rect.bottom);
      nodeEl.dataset.dropPosition = 'after';
    } else {
      nodeEl.classList.add('drag-over-parent');
      nodeEl.dataset.dropPosition = 'into';
    }
  });

  tree.addEventListener('dragleave', e => {
    if (!tree.contains(e.relatedTarget)) clearDropVisuals();
  });

  tree.addEventListener('drop', e => {
    e.preventDefault();
    if (!dragSourcePath) return;

    const header = e.target.closest('.node-header');
    if (!header) { clearDropVisuals(); return; }

    const targetPath = JSON.parse(header.dataset.path);
    const nodeEl = header.closest('.node');
    const position = nodeEl.dataset.dropPosition;

    if (!position || isDescendantOrSelf(targetPath, dragSourcePath)) {
      clearDropVisuals(); return;
    }

    performMove(dragSourcePath, targetPath, position);
    dragSourcePath = null;
    clearDropVisuals();
  });
})();

// --- Vim navigation ---
(function vimMode() {
  let focusIdx = -1;
  let pending = '';

  function items() {
    return Array.from(document.querySelectorAll('#tree .focusable[data-fkey]'));
  }

  function focus(idx) {
    const els = items();
    if (!els.length) return;
    els.forEach(el => el.classList.remove('focused'));
    focusIdx = Math.max(0, Math.min(idx, els.length - 1));
    const el = els[focusIdx];
    el.classList.add('focused');
    vimFocusKey = el.dataset.fkey;
    el.scrollIntoView({block: 'nearest'});
  }

  function info() {
    const els = items();
    const el = els[focusIdx];
    if (!el) return null;
    const fk = el.dataset.fkey;
    if (fk.startsWith('h:')) {
      const pk = fk.substring(2);
      return { type: 'header', pk, path: pk.split('-').map(Number), el };
    }
    if (fk.startsWith('c:')) {
      const rest = fk.substring(2);
      const lastColon = rest.lastIndexOf(':');
      const pk = rest.substring(0, lastColon);
      const field = rest.substring(lastColon + 1);
      return { type: 'content', pk, path: pk.split('-').map(Number), field, el };
    }
    return null;
  }

  document.addEventListener('keydown', e => {
    if (!window.vimEnabled) return;
    if (editing) return;
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    const key = e.key;

    // Pending combos
    if (pending === 'g' && key === 'g') {
      e.preventDefault(); pending = ''; focus(0); return;
    }
    pending = '';

    const fi = info();

    switch (key) {
      case 'j': e.preventDefault(); focus(focusIdx + 1); break;
      case 'k': e.preventDefault(); focus(focusIdx - 1); break;
      case 'l':
      case 'Enter': {
        e.preventDefault();
        if (!fi) break;
        if (fi.type === 'content') {
          startEdit(fi.el, fi.path, fi.field, true, true);
          break;
        }
        const node = nodeAt(fi.path);
        if (!isLeaf(node)) {
          if (!openNodes.has(fi.pk)) { openNodes.add(fi.pk); renderTree(); highlight(); focus(focusIdx); }
        } else if (node.details || node.description) {
          if (!openDetailsSet.has(fi.pk)) { openDetailsSet.add(fi.pk); renderTree(); highlight(); focus(focusIdx); }
        }
        break;
      }
      case 'h': {
        e.preventDefault();
        if (!fi) break;
        if (fi.type === 'content') {
          // Go to parent header
          const hKey = 'h:' + fi.pk;
          const els = items();
          const idx = els.findIndex(el => el.dataset.fkey === hKey);
          if (idx >= 0) focus(idx);
          break;
        }
        const node = nodeAt(fi.path);
        if (!isLeaf(node) && openNodes.has(fi.pk)) {
          openNodes.delete(fi.pk); renderTree(); highlight(); focus(focusIdx);
        } else if (isLeaf(node) && (node.details || node.description) && openDetailsSet.has(fi.pk)) {
          openDetailsSet.delete(fi.pk); renderTree(); highlight(); focus(focusIdx);
        } else if (fi.path.length > 1) {
          const parentKey = 'h:' + pathKey(fi.path.slice(0, -1));
          const els = items();
          const idx = els.findIndex(el => el.dataset.fkey === parentKey);
          if (idx >= 0) focus(idx);
        }
        break;
      }
      case ' ': {
        e.preventDefault();
        if (!fi) break;
        const node = nodeAt(fi.path);
        if (isLeaf(node)) { cycleLeafStatus(node); focus(focusIdx); }
        break;
      }
      case 'o': {
        e.preventDefault();
        if (!fi || fi.type !== 'header') break;
        const node = nodeAt(fi.path);
        if (!isLeaf(node)) { toggleNode(fi.pk); focus(focusIdx); }
        else if (node.details || node.description) { toggleDetails(fi.pk); focus(focusIdx); }
        break;
      }
      case 'g': pending = 'g'; break;
      case 'G': e.preventDefault(); focus(items().length - 1); break;
      case 'i': {
        e.preventDefault();
        if (!fi) break;
        if (fi.type === 'content') {
          startEdit(fi.el, fi.path, fi.field, true, true);
        } else {
          const nameEl = fi.el.querySelector('[data-field="name"]');
          if (nameEl) startEdit(nameEl, fi.path, 'name', false);
        }
        break;
      }
      case '?': {
        e.preventDefault();
        const help = document.getElementById('vim-help');
        if (help) help.style.display = help.style.display === 'none' ? '' : 'none';
        break;
      }
      default: return;
    }
  });

  const h = document.createElement('div');
  h.id = 'vim-help';
  h.className = 'vim-help';
  h.innerHTML = [
    '<kbd>j</kbd>/<kbd>k</kbd> move (into text blocks)',
    '<kbd>h</kbd>/<kbd>l</kbd> collapse/expand',
    '<kbd>space</kbd> cycle status',
    '<kbd>o</kbd> toggle',
    '<kbd>gg</kbd> top  <kbd>G</kbd> bottom',
    '<kbd>i</kbd>/<kbd>Enter</kbd> edit',
    '<kbd>?</kbd> toggle help',
  ].join('<br>');
  document.body.appendChild(h);
})();
</script>
</body>
</html>
